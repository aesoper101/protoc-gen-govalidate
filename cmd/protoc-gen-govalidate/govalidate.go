package main

import (
	"github.com/aesoper101/go-utils/str"
	"github.com/aesoper101/protoc-gen-govalidate/govalidate"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

var (
	validatorPackage = protogen.GoImportPath("github.com/aesoper101/protoc-gen-govalidate/validator")
	contextPackage   = protogen.GoImportPath("context")
)

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {

	if len(file.Messages) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_go_validate.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-validate. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	g.QualifiedGoIdent(contextPackage.Ident(""))
	g.QualifiedGoIdent(validatorPackage.Ident(""))

	generateFileContent(gen, file, g)
	return g
}

func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Messages) == 0 {
		return
	}
	rw := &ruleInfoWrapper{
		Rules: make(map[string]*ruleInfo),
	}
	for _, message := range file.Messages {
		generateValidateFunc(gen, file, message, rw)
	}

	g.P(rw.execute())
}

func generateValidateFunc(gen *protogen.Plugin, file *protogen.File, message *protogen.Message, wrapper *ruleInfoWrapper) {
	ruleName := str.ToLowerCamel(message.GoIdent.GoName)

	rInf := &ruleInfo{
		Name:       ruleName,
		FieldRules: make([]fieldRule, 0),
		GoIdent:    message.GoIdent,
	}

	for _, field := range message.Fields {
		if proto.HasExtension(field.Desc.Options(), govalidate.E_Validate) {
			ruleExt := proto.GetExtension(field.Desc.Options(), govalidate.E_Validate)
			if ruleFieldRule, ok := ruleExt.(string); ok {

				ruleFieldName := field.GoName

				rInf.FieldRules = append(rInf.FieldRules, fieldRule{
					Name:          ruleFieldName,
					Value:         ruleFieldRule,
					GoPackageName: string(file.GoPackageName),
				})

				wrapper.Rules[ruleName] = rInf

				if field.Message != nil {
					generateValidateFunc(gen, file, field.Message, wrapper)
				}
			}
		}
	}

}
